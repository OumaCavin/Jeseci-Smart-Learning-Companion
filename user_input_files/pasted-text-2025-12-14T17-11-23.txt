
seed_jac_concepts.py
#!/usr/bin/env python3
"""
JAC Programming Language Concepts Seeding Script
Based on the comprehensive JAC Learning Guide provided
"""

import json
import os
from datetime import datetime
from sqlalchemy.orm import Session
from config.database import SessionLocal, engine
from database.models.sqlite_models import (
Â  Â  User, Concept, LearningPath, LearningPathConcept, 
Â  Â  UserProgress, UserLearningPreferences
)

def create_jac_concepts(db: Session):
Â  Â  """Create JAC programming concepts from the learning guide"""
Â  Â  print("ðŸŽ¯ Creating JAC Programming Language Concepts...")
Â  Â  
Â  Â  # Check if JAC concepts already exist
Â  Â  existing_jac_concepts = db.query(Concept).filter(Concept.category == "JAC Programming").count()
Â  Â  if existing_jac_concepts > 0:
Â  Â  Â  Â  print("âœ… JAC concepts already exist")
Â  Â  Â  Â  return
Â  Â  
Â  Â  # Define JAC concepts based on the learning guide
Â  Â  jac_concepts = [
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_programming_fundamentals",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Programming Fundamentals",
Â  Â  Â  Â  Â  Â  "description": "Introduction to JAC (Java-like Architecture for Computation) programming language with Object-Spatial Programming paradigm",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC is a revolutionary programming language that introduces Object-Spatial Programming (OSP) where computation moves to data, enabling scalable and distributed applications. It offers a unique dual paradigm: traditional programming and Object-Spatial Programming.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Introduction",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "beginner",
Â  Â  Â  Â  Â  Â  "complexity_score": 6.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 6.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["JAC", "Object-Spatial Programming", "OSP", "nodes", "edges", "walkers"],
Â  Â  Â  Â  Â  Â  "synonyms": ["Java-like Architecture for Computation", "JAC Language"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Understand what JAC programming language is and its unique features",
Â  Â  Â  Â  Â  Â  Â  Â  "Learn the dual programming paradigm approach",
Â  Â  Â  Â  Â  Â  Â  Â  "Identify the advantages of Object-Spatial Programming",
Â  Â  Â  Â  Â  Â  Â  Â  "Set up JAC development environment"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Building scalable distributed applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating graph-based data structures",
Â  Â  Â  Â  Â  Â  Â  Â  "Developing applications with automatic persistence",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing multi-user isolated systems"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Social network applications with friend relationships",
Â  Â  Â  Â  Â  Â  Â  Â  "Knowledge graph systems for educational content",
Â  Â  Â  Â  Â  Â  Â  Â  "Distributed computing applications",
Â  Â  Â  Â  Â  Â  Â  Â  "AI-powered recommendation systems"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "JAC is just another programming language like Java",
Â  Â  Â  Â  Â  Â  Â  Â  "Object-Spatial Programming is too complex for beginners",
Â  Â  Â  Â  Â  Â  Â  Â  "Traditional programming concepts don't apply to JAC",
Â  Â  Â  Â  Â  Â  Â  Â  "JAC only works for graph-based applications"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_variables_data_types",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Variables and Data Types",
Â  Â  Â  Â  Â  Â  "description": "Understanding JAC's type system, variable declarations, and data type annotations",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC uses strong typing with type annotations for all variables and collections. Variables are declared with the assignment operator and require explicit type annotations. Supported types include str, int, float, bool, list, dict, set, and tuples.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Fundamentals",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "beginner",
Â  Â  Â  Â  Â  Â  "complexity_score": 4.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 4.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["variable", "type annotation", "string", "integer", "float", "boolean", "list", "dict", "set"],
Â  Â  Â  Â  Â  Â  "synonyms": ["data types", "variable declaration", "type system"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Declare variables with proper type annotations",
Â  Â  Â  Â  Â  Â  Â  Â  "Understand JAC's primitive data types",
Â  Â  Â  Â  Â  Â  Â  Â  "Work with collection types (lists, dictionaries, sets)",
Â  Â  Â  Â  Â  Â  Â  Â  "Use f-strings for string formatting"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Storing user information and profiles",
Â  Â  Â  Â  Â  Â  Â  Â  "Managing collections of data",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating data structures for applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing type-safe programming patterns"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Student grade management system",
Â  Â  Â  Â  Â  Â  Â  Â  "User profile with contact information",
Â  Â  Â  Â  Â  Â  Â  Â  "Inventory tracking with quantities and prices",
Â  Â  Â  Â  Â  Â  Â  Â  "Social media post data storage"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Type annotations are optional in JAC",
Â  Â  Â  Â  Â  Â  Â  Â  "JAC uses dynamic typing like Python",
Â  Â  Â  Â  Â  Â  Â  Â  "Collections don't need type specifications",
Â  Â  Â  Â  Â  Â  Â  Â  "Type annotations only apply to function parameters"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_control_flow",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Control Flow",
Â  Â  Â  Â  Â  Â  "description": "Mastering conditional statements, loops, and pattern matching in JAC",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC provides traditional control flow structures including if-elif-else statements, while loops, for loops (counting and iterating), and advanced pattern matching. All control structures use curly braces for block definition.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Fundamentals", 
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "beginner",
Â  Â  Â  Â  Â  Â  "complexity_score": 5.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 5.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["if", "elif", "else", "while", "for", "break", "continue", "pattern matching", "comparison operators"],
Â  Â  Â  Â  Â  Â  "synonyms": ["conditionals", "loops", "decision making", "iteration"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Write conditional statements with proper syntax",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement loops for repetitive tasks",
Â  Â  Â  Â  Â  Â  Â  Â  "Use comparison and logical operators effectively",
Â  Â  Â  Â  Â  Â  Â  Â  "Apply pattern matching for complex conditions"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "User input validation and processing",
Â  Â  Â  Â  Â  Â  Â  Â  "Data filtering and processing",
Â  Â  Â  Â  Â  Â  Â  Â  "Game logic and state management",
Â  Â  Â  Â  Â  Â  Â  Â  "Business rule implementation"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Grade calculation and letter grade assignment",
Â  Â  Â  Â  Â  Â  Â  Â  "User authentication and authorization",
Â  Â  Â  Â  Â  Â  Â  Â  "Inventory management and stock checking",
Â  Â  Â  Â  Â  Â  Â  Â  "Game scoring and level progression"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "JAC uses Python-style indentation for blocks",
Â  Â  Â  Â  Â  Â  Â  Â  "Pattern matching replaces all if-elif-else chains",
Â  Â  Â  Â  Â  Â  Â  Â  "Loops automatically handle boundary conditions",
Â  Â  Â  Â  Â  Â  Â  Â  "Comparison operators work the same as in other languages"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_functions",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Functions",
Â  Â  Â  Â  Â  Â  "description": "Creating reusable code blocks with parameters, return values, and default arguments",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC functions are defined using the 'def' keyword with type annotations for parameters and return types. Functions support default parameters, named parameters, and can return values using the 'return' statement.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Fundamentals",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "beginner",
Â  Â  Â  Â  Â  Â  "complexity_score": 5.5,
Â  Â  Â  Â  Â  Â  "cognitive_load": 6.0,
Â  Â  Â  Â  Â  Â  "key_terms": ["function", "parameter", "return", "default parameter", "type annotation", "named parameter"],
Â  Â  Â  Â  Â  Â  "synonyms": ["method", "procedure", "subroutine", "function definition"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Define functions with proper type annotations",
Â  Â  Â  Â  Â  Â  Â  Â  "Use parameters and return values effectively",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement default parameters for flexibility",
Â  Â  Â  Â  Â  Â  Â  Â  "Apply functions to solve programming problems"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Creating utility functions for common operations",
Â  Â  Â  Â  Â  Â  Â  Â  "Building calculator and mathematical functions",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing data validation and processing",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating reusable code components"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Mathematical calculator functions",
Â  Â  Â  Â  Â  Â  Â  Â  "Data validation and sanitization functions",
Â  Â  Â  Â  Â  Â  Â  Â  "User interface helper functions",
Â  Â  Â  Â  Â  Â  Â  Â  "API response processing functions"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Functions don't need return type annotations",
Â  Â  Â  Â  Â  Â  Â  Â  "Default parameters work like Python",
Â  Â  Â  Â  Â  Â  Â  Â  "Functions can only return one value",
Â  Â  Â  Â  Â  Â  Â  Â  "Type annotations are optional for function parameters"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_collections",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Collections and Data Structures",
Â  Â  Â  Â  Â  Â  "description": "Working with lists, dictionaries, sets, and collection comprehensions in JAC",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC supports lists, dictionaries, sets, and tuples with strong typing. All collections require explicit type annotations and support comprehensions similar to Python. Collections are fundamental for organizing and managing data.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Intermediate",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "intermediate",
Â  Â  Â  Â  Â  Â  "complexity_score": 6.5,
Â  Â  Â  Â  Â  Â  "cognitive_load": 7.0,
Â  Â  Â  Â  Â  Â  "key_terms": ["list", "dictionary", "set", "tuple", "collection comprehension", "append", "extend", "items"],
Â  Â  Â  Â  Â  Â  "synonyms": ["data structures", "arrays", "maps", "hash tables"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Create and manipulate typed collections",
Â  Â  Â  Â  Â  Â  Â  Â  "Use collection comprehensions for data processing",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement common collection operations",
Â  Â  Â  Â  Â  Â  Â  Â  "Choose appropriate collection types for different use cases"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Managing user data and profiles",
Â  Â  Â  Â  Â  Â  Â  Â  "Storing and processing large datasets",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing lookup tables and caches",
Â  Â  Â  Â  Â  Â  Â  Â  "Building data pipelines and transformations"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Student gradebook with multiple subjects",
Â  Â  Â  Â  Â  Â  Â  Â  "Inventory management system",
Â  Â  Â  Â  Â  Â  Â  Â  "Social media post collections",
Â  Â  Â  Â  Â  Â  Â  Â  "E-commerce product catalogs"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Collections can be created without type annotations",
Â  Â  Â  Â  Â  Â  Â  Â  "List comprehensions work exactly like Python",
Â  Â  Â  Â  Â  Â  Â  Â  "All collection types support the same operations",
Â  Â  Â  Â  Â  Â  Â  Â  "Collections are automatically persisted"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_oop",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Object-Oriented Programming",
Â  Â  Â  Â  Â  Â  "description": "Implementing classes, objects, methods, and interface/implementation separation",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC supports OOP with 'obj' keyword for defining classes, 'has' for attributes, and 'def' for methods. It encourages separation between interface (.jac) and implementation (.impl.jac) files for better code organization.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Intermediate",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "intermediate",
Â  Â  Â  Â  Â  Â  "complexity_score": 7.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 7.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["object", "class", "method", "attribute", "self", "interface", "implementation", "obj"],
Â  Â  Â  Â  Â  Â  "synonyms": ["OOP", "object-oriented", "class-based programming"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Define objects with attributes and methods",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement interface/implementation separation",
Â  Â  Â  Â  Â  Â  Â  Â  "Use 'self' reference correctly",
Â  Â  Â  Â  Â  Â  Â  Â  "Create reusable object-oriented designs"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Building data models and entities",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating reusable business logic components",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing game objects and entities",
Â  Â  Â  Â  Â  Â  Â  Â  "Designing application architecture"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Student and Course management systems",
Â  Â  Â  Â  Â  Â  Â  Â  "E-commerce product and order objects",
Â  Â  Â  Â  Â  Â  Â  Â  "Game characters and inventory systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Banking account and transaction objects"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "JAC objects work exactly like Python classes",
Â  Â  Â  Â  Â  Â  Â  Â  "Interface separation is optional",
Â  Â  Â  Â  Â  Â  Â  Â  "All methods need 'self' parameter",
Â  Â  Â  Â  Â  Â  Â  Â  "Objects are automatically persisted"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_object_spatial_programming",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Object-Spatial Programming (OSP)",
Â  Â  Â  Â  Â  Â  "description": "Understanding the revolutionary OSP paradigm with nodes, edges, and walkers",
Â  Â  Â  Â  Â  Â  "detailed_description": "Object-Spatial Programming is JAC's unique paradigm where computation moves to data. Built on three fundamentals: Nodes (stateful entities), Edges (typed relationships), and Walkers (mobile computation that traverses graphs).",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Advanced",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "advanced",
Â  Â  Â  Â  Â  Â  "complexity_score": 8.5,
Â  Â  Â  Â  Â  Â  "cognitive_load": 9.0,
Â  Â  Â  Â  Â  Â  "key_terms": ["Object-Spatial Programming", "OSP", "node", "edge", "walker", "graph", "traversal", "scale-agnostic"],
Â  Â  Â  Â  Â  Â  "synonyms": ["graph programming", "spatial computation", "distributed programming"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Understand the OSP paradigm fundamentals",
Â  Â  Â  Â  Â  Â  Â  Â  "Create nodes and edges for data relationships",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement walkers for graph traversal",
Â  Â  Â  Â  Â  Â  Â  Â  "Apply scale-agnostic programming principles"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Building social network applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating knowledge graph systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing recommendation engines",
Â  Â  Â  Â  Â  Â  Â  Â  "Developing distributed data processing"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Facebook-style social network with friend relationships",
Â  Â  Â  Â  Â  Â  Â  Â  "Academic paper citation networks",
Â  Â  Â  Â  Â  Â  Â  Â  "E-commerce product recommendation systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Transportation route optimization"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "OSP is just another name for graph databases",
Â  Â  Â  Â  Â  Â  Â  Â  "Nodes and edges are the same as classes and relationships",
Â  Â  Â  Â  Â  Â  Â  Â  "Walkers are like regular functions",
Â  Â  Â  Â  Â  Â  Â  Â  "OSP only works for social networks"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_nodes_edges",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Nodes and Edges",
Â  Â  Â  Â  Â  Â  "description": "Creating and managing nodes (data entities) and edges (relationships) in JAC",
Â  Â  Â  Â  Â  Â  "detailed_description": "Nodes are objects with location in graph structure, created using 'node' keyword. Edges create typed connections between nodes and can have properties. Both support inheritance and complex relationship modeling.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Advanced",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "advanced",
Â  Â  Â  Â  Â  Â  "complexity_score": 8.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 8.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["node", "edge", "relationship", "graph structure", "typed edge", "edge properties", "root"],
Â  Â  Â  Â  Â  Â  "synonyms": ["vertices", "connections", "links", "associations"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Create nodes with appropriate attributes",
Â  Â  Â  Â  Â  Â  Â  Â  "Define typed edges with properties",
Â  Â  Â  Â  Â  Â  Â  Â  "Establish complex relationships between entities",
Â  Â  Â  Â  Â  Â  Â  Â  "Understand graph traversal patterns"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Modeling complex business relationships",
Â  Â  Â  Â  Â  Â  Â  Â  "Building knowledge representation systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating network topology models",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing hierarchical data structures"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Company organizational charts",
Â  Â  Â  Â  Â  Â  Â  Â  "Academic course prerequisites",
Â  Â  Â  Â  Â  Â  Â  Â  "Supply chain management systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Social media follower networks"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Nodes are just regular objects",
Â  Â  Â  Â  Â  Â  Â  Â  "Edges can only connect two nodes",
Â  Â  Â  Â  Â  Â  Â  Â  "Graph structure is automatically optimized",
Â  Â  Â  Â  Â  Â  Â  Â  "All relationships are bidirectional"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_walkers",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Walkers and Graph Traversal",
Â  Â  Â  Â  Â  Â  "description": "Implementing mobile computation through walkers that traverse graphs of nodes and edges",
Â  Â  Â  Â  Â  Â  "detailed_description": "Walkers are programs that traverse graphs performing tasks. They have 'can' abilities that execute when landing on specific node types. Walkers use 'visit' statements to traverse edges and 'spawn' to initiate traversal.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Advanced",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "advanced",
Â  Â  Â  Â  Â  Â  "complexity_score": 8.5,
Â  Â  Â  Â  Â  Â  "cognitive_load": 9.0,
Â  Â  Â  Â  Â  Â  "key_terms": ["walker", "spawn", "visit", "traverse", "ability", "here", "entry"],
Â  Â  Â  Â  Â  Â  "synonyms": ["mobile agents", "graph algorithms", "traversal agents"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Create walkers with appropriate abilities",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement graph traversal algorithms",
Â  Â  Â  Â  Â  Â  Â  Â  "Use 'visit' and 'spawn' effectively",
Â  Â  Â  Â  Â  Â  Â  Â  "Design efficient walker workflows"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing search and discovery algorithms",
Â  Â  Â  Â  Â  Â  Â  Â  "Building recommendation and suggestion systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating data analysis and reporting tools",
Â  Â  Â  Â  Â  Â  Â  Â  "Developing network monitoring systems"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "Friend recommendation algorithms",
Â  Â  Â  Â  Â  Â  Â  Â  "Web crawling and indexing systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Network diagnostic tools",
Â  Â  Â  Â  Â  Â  Â  Â  "Social media content discovery"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Walkers are like regular functions",
Â  Â  Â  Â  Â  Â  Â  Â  "Graph traversal is always linear",
Â  Â  Â  Â  Â  Â  Â  Â  "Walkers automatically optimize their path",
Â  Â  Â  Â  Â  Â  Â  Â  "All traversal requires manual edge navigation"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_ai_integration",
Â  Â  Â  Â  Â  Â  "display_name": "JAC AI Integration with byLLM",
Â  Â  Â  Â  Â  Â  "description": "Integrating Large Language Models into JAC applications using byLLM annotations",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC provides native AI integration through byLLM annotations. Functions can be marked with 'byllm()' to have their implementation generated by configured LLMs, enabling dynamic content generation and intelligent responses.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Expert",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "expert",
Â  Â  Â  Â  Â  Â  "complexity_score": 9.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 9.5,
Â  Â  Â  Â  Â  Â  "key_terms": ["byLLM", "AI integration", "LLM", "Model", "artificial intelligence", "dynamic generation"],
Â  Â  Â  Â  Â  Â  "synonyms": ["machine learning integration", "AI-powered programming", "LLM annotation"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Configure LLM models for JAC applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement functions with byLLM annotations",
Â  Â  Â  Â  Â  Â  Â  Â  "Handle AI-generated content appropriately",
Â  Â  Â  Â  Â  Â  Â  Â  "Build intelligent user interactions"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Creating conversational AI applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Generating dynamic content and responses",
Â  Â  Â  Â  Â  Â  Â  Â  "Building intelligent tutoring systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing automated code generation"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "AI-powered chatbots and virtual assistants",
Â  Â  Â  Â  Â  Â  Â  Â  "Dynamic educational content generation",
Â  Â  Â  Â  Â  Â  Â  Â  "Intelligent coding challenge creation",
Â  Â  Â  Â  Â  Â  Â  Â  "Automated report and documentation generation"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "byLLM functions work without configuration",
Â  Â  Â  Â  Â  Â  Â  Â  "AI integration is only for text generation",
Â  Â  Â  Â  Â  Â  Â  Â  "LLM responses are always accurate",
Â  Â  Â  Â  Â  Â  Â  Â  "byLLM replaces traditional programming"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "jac_scale_agnostic_programming",
Â  Â  Â  Â  Â  Â  "display_name": "JAC Scale-Agnostic Programming",
Â  Â  Â  Â  Â  Â  "description": "Building applications that work seamlessly from single user to millions of users",
Â  Â  Â  Â  Â  Â  "detailed_description": "JAC enables scale-agnostic programming where code works for single users or millions without changes. This is achieved through automatic persistence, multi-user isolation, and graph-based architecture.",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "subcategory": "Expert",
Â  Â  Â  Â  Â  Â  "domain": "Computer Science",
Â  Â  Â  Â  Â  Â  "difficulty_level": "expert",
Â  Â  Â  Â  Â  Â  "complexity_score": 9.0,
Â  Â  Â  Â  Â  Â  "cognitive_load": 9.0,
Â  Â  Â  Â  Â  Â  "key_terms": ["scale-agnostic", "automatic persistence", "multi-user", "isolation", "distributed"],
Â  Â  Â  Â  Â  Â  "synonyms": ["elastic programming", "auto-scaling", "cloud-native"],
Â  Â  Â  Â  Â  Â  "learning_objectives": [
Â  Â  Â  Â  Â  Â  Â  Â  "Understand scale-agnostic programming principles",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement applications that scale automatically",
Â  Â  Â  Â  Â  Â  Â  Â  "Leverage automatic persistence features",
Â  Â  Â  Â  Â  Â  Â  Â  "Design for multi-user environments"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "practical_applications": [
Â  Â  Â  Â  Â  Â  Â  Â  "Building cloud-native applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Creating auto-scaling services",
Â  Â  Â  Â  Â  Â  Â  Â  "Implementing multi-tenant systems",
Â  Â  Â  Â  Â  Â  Â  Â  "Developing global-scale applications"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "real_world_examples": [
Â  Â  Â  Â  Â  Â  Â  Â  "SaaS applications with automatic scaling",
Â  Â  Â  Â  Â  Â  Â  Â  "Multi-tenant e-commerce platforms",
Â  Â  Â  Â  Â  Â  Â  Â  "Global social media applications",
Â  Â  Â  Â  Â  Â  Â  Â  "Enterprise collaboration systems"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "common_misconceptions": [
Â  Â  Â  Â  Â  Â  Â  Â  "Scale-agnostic means no performance considerations",
Â  Â  Â  Â  Â  Â  Â  Â  "Automatic persistence works for all data types",
Â  Â  Â  Â  Â  Â  Â  Â  "Multi-user isolation is automatic for all operations",
Â  Â  Â  Â  Â  Â  Â  Â  "Scale-agnostic code works the same at all sizes"
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  }
Â  Â  ]
Â  Â  
Â  Â  # Create concepts
Â  Â  for concept_data in jac_concepts:
Â  Â  Â  Â  # Check if concept already exists
Â  Â  Â  Â  existing_concept = db.query(Concept).filter(Concept.name == concept_data["name"]).first()
Â  Â  Â  Â  if not existing_concept:
Â  Â  Â  Â  Â  Â  concept = Concept(
Â  Â  Â  Â  Â  Â  Â  Â  name=concept_data["name"],
Â  Â  Â  Â  Â  Â  Â  Â  display_name=concept_data["display_name"],
Â  Â  Â  Â  Â  Â  Â  Â  description=concept_data["description"],
Â  Â  Â  Â  Â  Â  Â  Â  detailed_description=concept_data["detailed_description"],
Â  Â  Â  Â  Â  Â  Â  Â  category=concept_data["category"],
Â  Â  Â  Â  Â  Â  Â  Â  subcategory=concept_data["subcategory"],
Â  Â  Â  Â  Â  Â  Â  Â  domain=concept_data["domain"],
Â  Â  Â  Â  Â  Â  Â  Â  difficulty_level=concept_data["difficulty_level"],
Â  Â  Â  Â  Â  Â  Â  Â  complexity_score=concept_data["complexity_score"],
Â  Â  Â  Â  Â  Â  Â  Â  cognitive_load=concept_data["cognitive_load"],
Â  Â  Â  Â  Â  Â  Â  Â  key_terms=concept_data["key_terms"],
Â  Â  Â  Â  Â  Â  Â  Â  synonyms=concept_data["synonyms"],
Â  Â  Â  Â  Â  Â  Â  Â  learning_objectives=concept_data["learning_objectives"],
Â  Â  Â  Â  Â  Â  Â  Â  practical_applications=concept_data["practical_applications"],
Â  Â  Â  Â  Â  Â  Â  Â  real_world_examples=concept_data["real_world_examples"],
Â  Â  Â  Â  Â  Â  Â  Â  common_misconceptions=concept_data["common_misconceptions"],
Â  Â  Â  Â  Â  Â  Â  Â  created_at=datetime.utcnow(),
Â  Â  Â  Â  Â  Â  Â  Â  updated_at=datetime.utcnow()
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  db.add(concept)
Â  Â  Â  Â  Â  Â  print(f"âœ… Created concept: {concept_data['display_name']}")
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  print(f"âœ… Concept already exists: {concept_data['display_name']}")
Â  Â  
Â  Â  db.commit()

def create_jac_learning_paths(db: Session):
Â  Â  """Create JAC-specific learning paths"""
Â  Â  print("ðŸ›¤ï¸ Creating JAC Learning Paths...")
Â  Â  
Â  Â  # Check if JAC learning paths already exist
Â  Â  existing_paths = db.query(LearningPath).filter(LearningPath.category == "JAC Programming").count()
Â  Â  if existing_paths > 0:
Â  Â  Â  Â  print("âœ… JAC learning paths already exist")
Â  Â  Â  Â  return
Â  Â  
Â  Â  # JAC Learning Paths based on the guide structure
Â  Â  learning_paths = [
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "JAC Programming Fundamentals Journey",
Â  Â  Â  Â  Â  Â  "description": "Master the essential concepts of JAC programming from basic syntax to Object-Spatial Programming",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "difficulty_level": "beginner",
Â  Â  Â  Â  Â  Â  "estimated_duration": 40,
Â  Â  Â  Â  Â  Â  "target_audience": "Beginner programmers new to JAC",
Â  Â  Â  Â  Â  Â  "prerequisites": [],
Â  Â  Â  Â  Â  Â  "learning_outcomes": [
Â  Â  Â  Â  Â  Â  Â  Â  "Understand JAC's unique dual programming paradigm",
Â  Â  Â  Â  Â  Â  Â  Â  "Master basic syntax, variables, and data types",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement control flow and functions effectively",
Â  Â  Â  Â  Â  Â  Â  Â  "Set up and use JAC development environment"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "is_public": True
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "JAC Object-Oriented and Collections Mastery",
Â  Â  Â  Â  Â  Â  "description": "Advanced JAC programming with OOP, collections, and interface separation",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "difficulty_level": "intermediate",
Â  Â  Â  Â  Â  Â  "estimated_duration": 35,
Â  Â  Â  Â  Â  Â  "target_audience": "Intermediate programmers with JAC basics",
Â  Â  Â  Â  Â  Â  "prerequisites": ["JAC Programming Fundamentals Journey"],
Â  Â  Â  Â  Â  Â  "learning_outcomes": [
Â  Â  Â  Â  Â  Â  Â  Â  "Implement object-oriented programming in JAC",
Â  Â  Â  Â  Â  Â  Â  Â  "Work effectively with collections and data structures",
Â  Â  Â  Â  Â  Â  Â  Â  "Apply interface/implementation separation patterns",
Â  Â  Â  Â  Â  Â  Â  Â  "Build complex data models and relationships"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "is_public": True
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "JAC Object-Spatial Programming Expert",
Â  Â  Â  Â  Â  Â  "description": "Master the revolutionary OSP paradigm with nodes, edges, and walkers",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "difficulty_level": "advanced",
Â  Â  Â  Â  Â  Â  "estimated_duration": 50,
Â  Â  Â  Â  Â  Â  "target_audience": "Advanced programmers ready for OSP",
Â  Â  Â  Â  Â  Â  "prerequisites": ["JAC Object-Oriented and Collections Mastery"],
Â  Â  Â  Â  Â  Â  "learning_outcomes": [
Â  Â  Â  Â  Â  Â  Â  Â  "Understand Object-Spatial Programming fundamentals",
Â  Â  Â  Â  Â  Â  Â  Â  "Create and manage nodes and edges effectively",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement walkers for graph traversal",
Â  Â  Â  Â  Â  Â  Â  Â  "Build scale-agnostic distributed applications"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "is_public": True
Â  Â  Â  Â  },
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "name": "JAC AI Integration and Expert Level",
Â  Â  Â  Â  Â  Â  "description": "Expert-level JAC with AI integration, production deployment, and advanced features",
Â  Â  Â  Â  Â  Â  "category": "JAC Programming",
Â  Â  Â  Â  Â  Â  "difficulty_level": "expert",
Â  Â  Â  Â  Â  Â  "estimated_duration": 45,
Â  Â  Â  Â  Â  Â  "target_audience": "Expert programmers and system architects",
Â  Â  Â  Â  Â  Â  "prerequisites": ["JAC Object-Spatial Programming Expert"],
Â  Â  Â  Â  Â  Â  "learning_outcomes": [
Â  Â  Â  Â  Â  Â  Â  Â  "Integrate AI capabilities using byLLM",
Â  Â  Â  Â  Â  Â  Â  Â  "Implement scale-agnostic programming patterns",
Â  Â  Â  Â  Â  Â  Â  Â  "Deploy JAC applications in production",
Â  Â  Â  Â  Â  Â  Â  Â  "Master advanced JAC language features"
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "is_public": True
Â  Â  Â  Â  }
Â  Â  ]
Â  Â  
Â  Â  # Create learning paths
Â  Â  created_paths = []
Â  Â  for path_data in learning_paths:
Â  Â  Â  Â  path = LearningPath(
Â  Â  Â  Â  Â  Â  name=path_data["name"],
Â  Â  Â  Â  Â  Â  description=path_data["description"],
Â  Â  Â  Â  Â  Â  category=path_data["category"],
Â  Â  Â  Â  Â  Â  difficulty_level=path_data["difficulty_level"],
Â  Â  Â  Â  Â  Â  estimated_duration=path_data["estimated_duration"],
Â  Â  Â  Â  Â  Â  target_audience=path_data["target_audience"],
Â  Â  Â  Â  Â  Â  prerequisites=path_data["prerequisites"],
Â  Â  Â  Â  Â  Â  learning_outcomes=path_data["learning_outcomes"],
Â  Â  Â  Â  Â  Â  is_public=path_data["is_public"],
Â  Â  Â  Â  Â  Â  created_at=datetime.utcnow(),
Â  Â  Â  Â  Â  Â  updated_at=datetime.utcnow()
Â  Â  Â  Â  )
Â  Â  Â  Â  db.add(path)
Â  Â  Â  Â  created_paths.append((path, path_data))
Â  Â  Â  Â  print(f"âœ… Created learning path: {path_data['name']}")
Â  Â  
Â  Â  db.commit()
Â  Â  db.refresh(created_paths[0][0]) Â # Refresh the first path
Â  Â  
Â  Â  # Link concepts to learning paths based on prerequisites and difficulty
Â  Â  concepts = db.query(Concept).filter(Concept.category == "JAC Programming").all()
Â  Â  
Â  Â  # Path 1: Fundamentals (Beginner concepts)
Â  Â  fundamentals_path = next((p for p, d in created_paths if d["name"] == "JAC Programming Fundamentals Journey"), None)
Â  Â  if fundamentals_path:
Â  Â  Â  Â  fundamental_concepts = [
Â  Â  Â  Â  Â  Â  "jac_programming_fundamentals",
Â  Â  Â  Â  Â  Â  "jac_variables_data_types", 
Â  Â  Â  Â  Â  Â  "jac_control_flow",
Â  Â  Â  Â  Â  Â  "jac_functions"
Â  Â  Â  Â  ]
Â  Â  Â  Â  
Â  Â  Â  Â  order = 1
Â  Â  Â  Â  for concept_name in fundamental_concepts:
Â  Â  Â  Â  Â  Â  concept = next((c for c in concepts if c.name == concept_name), None)
Â  Â  Â  Â  Â  Â  if concept:
Â  Â  Â  Â  Â  Â  Â  Â  link = LearningPathConcept(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path_id=fundamentals_path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  concept_id=concept.concept_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sequence_order=order,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimated_duration=10 if order <= 2 else 8,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  required_mastery_level=0.0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adaptive_difficulty=True
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  db.add(link)
Â  Â  Â  Â  Â  Â  Â  Â  order += 1
Â  Â  
Â  Â  # Path 2: Intermediate (Collections and OOP)
Â  Â  intermediate_path = next((p for p, d in created_paths if d["name"] == "JAC Object-Oriented and Collections Mastery"), None)
Â  Â  if intermediate_path:
Â  Â  Â  Â  intermediate_concepts = [
Â  Â  Â  Â  Â  Â  "jac_collections",
Â  Â  Â  Â  Â  Â  "jac_oop"
Â  Â  Â  Â  ]
Â  Â  Â  Â  
Â  Â  Â  Â  order = 1
Â  Â  Â  Â  for concept_name in intermediate_concepts:
Â  Â  Â  Â  Â  Â  concept = next((c for c in concepts if c.name == concept_name), None)
Â  Â  Â  Â  Â  Â  if concept:
Â  Â  Â  Â  Â  Â  Â  Â  link = LearningPathConcept(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path_id=intermediate_path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  concept_id=concept.concept_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sequence_order=order,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimated_duration=18 if order == 1 else 17,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  required_mastery_level=0.7,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adaptive_difficulty=True
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  db.add(link)
Â  Â  Â  Â  Â  Â  Â  Â  order += 1
Â  Â  
Â  Â  # Path 3: Advanced (OSP concepts)
Â  Â  advanced_path = next((p for p, d in created_paths if d["name"] == "JAC Object-Spatial Programming Expert"), None)
Â  Â  if advanced_path:
Â  Â  Â  Â  advanced_concepts = [
Â  Â  Â  Â  Â  Â  "jac_object_spatial_programming",
Â  Â  Â  Â  Â  Â  "jac_nodes_edges",
Â  Â  Â  Â  Â  Â  "jac_walkers"
Â  Â  Â  Â  ]
Â  Â  Â  Â  
Â  Â  Â  Â  order = 1
Â  Â  Â  Â  for concept_name in advanced_concepts:
Â  Â  Â  Â  Â  Â  concept = next((c for c in concepts if c.name == concept_name), None)
Â  Â  Â  Â  Â  Â  if concept:
Â  Â  Â  Â  Â  Â  Â  Â  link = LearningPathConcept(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path_id=advanced_path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  concept_id=concept.concept_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sequence_order=order,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimated_duration=17 if order <= 2 else 16,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  required_mastery_level=0.8,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adaptive_difficulty=True
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  db.add(link)
Â  Â  Â  Â  Â  Â  Â  Â  order += 1
Â  Â  
Â  Â  # Path 4: Expert (AI and scale)
Â  Â  expert_path = next((p for p, d in created_paths if d["name"] == "JAC AI Integration and Expert Level"), None)
Â  Â  if expert_path:
Â  Â  Â  Â  expert_concepts = [
Â  Â  Â  Â  Â  Â  "jac_ai_integration",
Â  Â  Â  Â  Â  Â  "jac_scale_agnostic_programming"
Â  Â  Â  Â  ]
Â  Â  Â  Â  
Â  Â  Â  Â  order = 1
Â  Â  Â  Â  for concept_name in expert_concepts:
Â  Â  Â  Â  Â  Â  concept = next((c for c in concepts if c.name == concept_name), None)
Â  Â  Â  Â  Â  Â  if concept:
Â  Â  Â  Â  Â  Â  Â  Â  link = LearningPathConcept(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path_id=expert_path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  concept_id=concept.concept_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sequence_order=order,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimated_duration=23 if order == 1 else 22,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  required_mastery_level=0.9,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adaptive_difficulty=True
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  db.add(link)
Â  Â  Â  Â  Â  Â  Â  Â  order += 1
Â  Â  
Â  Â  db.commit()
Â  Â  print("âœ… Linked concepts to learning paths")

def main():
Â  Â  """Main seeding function for JAC concepts and learning paths"""
Â  Â  print("ðŸŽ¯ Starting JAC Programming Language Database Seeding...")
Â  Â  
Â  Â  # Create database session
Â  Â  db = SessionLocal()
Â  Â  
Â  Â  try:
Â  Â  Â  Â  # Create JAC concepts
Â  Â  Â  Â  create_jac_concepts(db)
Â  Â  Â  Â  
Â  Â  Â  Â  # Create JAC learning paths
Â  Â  Â  Â  create_jac_learning_paths(db)
Â  Â  Â  Â  
Â  Â  Â  Â  print("\nðŸŽ‰ JAC Programming Database seeding completed successfully!")
Â  Â  Â  Â  print("\nðŸ“Š Database Summary:")
Â  Â  Â  Â  print(f" Â  â€¢ JAC Concepts: {db.query(Concept).filter(Concept.category == 'JAC Programming').count()}")
Â  Â  Â  Â  print(f" Â  â€¢ JAC Learning Paths: {db.query(LearningPath).filter(LearningPath.category == 'JAC Programming').count()}")
Â  Â  Â  Â  print(f" Â  â€¢ Total Concepts: {db.query(Concept).count()}")
Â  Â  Â  Â  print(f" Â  â€¢ Total Learning Paths: {db.query(LearningPath).count()}")
Â  Â  Â  Â  
Â  Â  except Exception as e:
Â  Â  Â  Â  print(f"âŒ Error during JAC seeding: {e}")
Â  Â  Â  Â  db.rollback()
Â  Â  Â  Â  raise
Â  Â  finally:
Â  Â  Â  Â  db.close()

if __name__ == "__main__":
Â  Â  main()

The we also have link_jac_concepts_paths.py 
#!/usr/bin/env python3
"""
Link JAC concepts to JAC learning paths
Creates the missing relationships between concepts and learning paths
"""

from sqlalchemy.orm import Session
from config.database import SessionLocal
from database.models.sqlite_models import Concept, LearningPath, LearningPathConcept

def link_jac_concepts_to_paths():
Â  Â  """Link JAC concepts to JAC learning paths"""
Â  Â  db = SessionLocal()
Â  Â  
Â  Â  try:
Â  Â  Â  Â  print("ðŸ”— Linking JAC Concepts to Learning Paths...")
Â  Â  Â  Â  
Â  Â  Â  Â  # Get JAC concepts and paths
Â  Â  Â  Â  concepts = db.query(Concept).filter(Concept.category == "JAC Programming").all()
Â  Â  Â  Â  paths = db.query(LearningPath).filter(LearningPath.category == "JAC Programming").all()
Â  Â  Â  Â  
Â  Â  Â  Â  print(f"Found {len(concepts)} concepts and {len(paths)} paths")
Â  Â  Â  Â  
Â  Â  Â  Â  # Define the relationships based on difficulty and learning progression
Â  Â  Â  Â  path_concept_mappings = {
Â  Â  Â  Â  Â  Â  "JAC Programming Fundamentals Journey": [
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_programming_fundamentals", 1, 10),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_variables_data_types", 2, 10),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_control_flow", 3, 8),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_functions", 4, 8)
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "JAC Object-Oriented and Collections Mastery": [
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_collections", 1, 18),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_oop", 2, 17)
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "JAC Object-Spatial Programming Expert": [
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_object_spatial_programming", 1, 17),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_nodes_edges", 2, 17),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_walkers", 3, 16)
Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  "JAC AI Integration and Expert Level": [
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_ai_integration", 1, 23),
Â  Â  Â  Â  Â  Â  Â  Â  ("jac_scale_agnostic_programming", 2, 22)
Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  links_created = 0
Â  Â  Â  Â  
Â  Â  Â  Â  # Create relationships
Â  Â  Â  Â  for path_name, concept_mappings in path_concept_mappings.items():
Â  Â  Â  Â  Â  Â  path = next((p for p in paths if p.name == path_name), None)
Â  Â  Â  Â  Â  Â  if not path:
Â  Â  Â  Â  Â  Â  Â  Â  print(f"âŒ Path not found: {path_name}")
Â  Â  Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  print(f"\nðŸ“š Linking concepts to: {path_name}")
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  for concept_name, order, duration in concept_mappings:
Â  Â  Â  Â  Â  Â  Â  Â  concept = next((c for c in concepts if c.name == concept_name), None)
Â  Â  Â  Â  Â  Â  Â  Â  if not concept:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  print(f"âŒ Concept not found: {concept_name}")
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  # Check if relationship already exists
Â  Â  Â  Â  Â  Â  Â  Â  existing = db.query(LearningPathConcept).filter(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  LearningPathConcept.path_id == path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  LearningPathConcept.concept_id == concept.concept_id
Â  Â  Â  Â  Â  Â  Â  Â  ).first()
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if existing:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  print(f" Â âš ï¸ Â Relationship already exists: {concept.display_name}")
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  # Create new relationship
Â  Â  Â  Â  Â  Â  Â  Â  link = LearningPathConcept(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  path_id=path.path_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  concept_id=concept.concept_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sequence_order=order,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimated_duration=duration,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  required_mastery_level=0.0 if order == 1 else (0.7 if path.difficulty_level == "intermediate" else (0.8 if path.difficulty_level == "advanced" else 0.9)),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adaptive_difficulty=True
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  db.add(link)
Â  Â  Â  Â  Â  Â  Â  Â  links_created += 1
Â  Â  Â  Â  Â  Â  Â  Â  print(f" Â âœ… Linked: {concept.display_name} (Order: {order}, Duration: {duration}h)")
Â  Â  Â  Â  
Â  Â  Â  Â  # Commit all changes
Â  Â  Â  Â  db.commit()
Â  Â  Â  Â  
Â  Â  Â  Â  # Verify relationships
Â  Â  Â  Â  relationships = db.query(LearningPathConcept).join(
Â  Â  Â  Â  Â  Â  LearningPath, LearningPathConcept.path_id == LearningPath.path_id
Â  Â  Â  Â  ).filter(LearningPath.category == "JAC Programming").all()
Â  Â  Â  Â  
Â  Â  Â  Â  print(f"\nðŸŽ‰ Successfully created {links_created} new relationships!")
Â  Â  Â  Â  print(f"ðŸ“Š Total JAC concept-path relationships: {len(relationships)}")
Â  Â  Â  Â  
Â  Â  Â  Â  # Show summary by path
Â  Â  Â  Â  print(f"\nðŸ“ˆ Relationships by Learning Path:")
Â  Â  Â  Â  for path in paths:
Â  Â  Â  Â  Â  Â  path_rels = [r for r in relationships if r.path_id == path.path_id]
Â  Â  Â  Â  Â  Â  print(f" Â â€¢ {path.name}: {len(path_rels)} concepts")
Â  Â  Â  Â  
Â  Â  except Exception as e:
Â  Â  Â  Â  print(f"âŒ Error linking concepts to paths: {e}")
Â  Â  Â  Â  db.rollback()
Â  Â  Â  Â  raise
Â  Â  finally:
Â  Â  Â  Â  db.close()

if __name__ == "__main__":
Â  Â  link_jac_concepts_to_paths()